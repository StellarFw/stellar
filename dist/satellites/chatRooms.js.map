{"version":3,"sources":["satellites/chatRooms.js"],"names":[],"mappings":"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","file":"satellites/chatRooms.js","sourcesContent":["import async from 'async'\nimport Utils from '../utils'\n\nclass ChatRooms {\n\n  /**\n   * API reference.\n   *\n   * @type {null}\n   */\n  api = null\n\n  /**\n   * Keys to use to save rooms and members on redis server.\n   *\n   * @type {{rooms: string, members: string}}\n   */\n  keys = {\n    rooms: 'stellar:chatRoom:rooms',\n    members: 'stellar:chatRoom:members'\n  }\n\n  /**\n   * List of globals middleware.\n   *\n   * @type {Array}\n   */\n  globalMiddleware = []\n\n  /**\n   * List of all middleware.\n   *\n   * @type {{}}\n   */\n  middleware = {}\n\n  /**\n   * Constructor.\n   *\n   * @param api API reference.\n   */\n  constructor (api) { this.api = api }\n\n  /**\n   * Add a new middleware to the chat room manager.\n   *\n   * @param data  Middleware object.\n   */\n  addMiddleware (data) {\n    let self = this\n\n    // middleware must have a name\n    if (!data.name) { throw new Error('middleware.name is required') }\n\n    // if the middleware don't have a priority set a default value\n    if (!data.priority) { data.priority = self.api.config.general.defaultMiddlewarePriority }\n\n    // ensure the priority is a number\n    data.priority = Number(data.priority)\n\n    // save the middleware object\n    self.middleware[ data.name ] = data\n\n    // push the middleware name to the globalMiddleware\n    self.globalMiddleware.push(data.name)\n\n    // sort the globalMiddleware by priority\n    self.globalMiddleware.sort((a, b) => {\n      if (self.middleware[ a ].priority > self.middleware[ b ].priority) {\n        return 1\n      } else {\n        return -1\n      }\n    })\n  }\n\n  /**\n   * Broadcast a message in a room.\n   *\n   * @param connection  Source connection.\n   * @param room        Room here the message need to be broadcast.\n   * @param message     Message to broadcast.\n   * @param callback    Callback function.\n   */\n  broadcast (connection, room, message, callback) {\n    let self = this\n\n    // check if the room are present\n    if (!room || room.length === 0 || message === null || message.length === 0) {\n      if (typeof callback === 'function') {\n        process.nextTick(() => callback(self.api.config.errors.connectionRoomAndMessage(connection)))\n      }\n    } else if (connection.rooms === undefined || connection.rooms.indexOf(room) > -1) {\n      // set id zero for default if there no one present\n      if (connection.id === undefined) { connection.id = 0 }\n\n      // create a new payload\n      let payload = {\n        messageType: 'chat',\n        serverToken: self.api.config.general.serverToken,\n        serverId: self.api.id,\n        message: message,\n        sentAt: new Date().getTime(),\n        connection: {\n          id: connection.id,\n          room: room\n        }\n      }\n\n      // generate the message payload\n      let messagePayload = self._generateMessagePayload(payload)\n\n      // handle callbacks\n      self._handleCallbacks(connection, messagePayload.room, 'onSayReceive', messagePayload, (error, newPayload) => {\n        // if an error occurs execute the callback and send the error with him\n        if (error) {\n          if (typeof callback === 'function') {\n            process.nextTick(() => { callback(error) })\n          }\n          return\n        }\n\n        // create the payload to send\n        let payloadToSend = {\n          messageType: 'chat',\n          serverToken: self.api.config.general.serverToken,\n          serverId: self.api.id,\n          message: newPayload.message,\n          sentAt: newPayload.sentAt,\n          connection: {\n            id: newPayload.from,\n            room: newPayload.room\n          }\n        }\n\n        // send the payload to redis\n        self.api.redis.publish(payloadToSend)\n\n        // execute the callback\n        if (typeof callback === 'function') {\n          process.nextTick(() => {\n            callback(null)\n          })\n        }\n      })\n    } else {\n      if (typeof callback === 'function') {\n        process.nextTick(() => {\n          callback(self.api.config.errors.connectionNotInRoom(connection, room))\n        })\n      }\n    }\n  }\n\n  /**\n   * Process an incoming message.\n   *\n   * @param message Incoming message to be processed.\n   */\n  incomingMessage (message) {\n    let self = this\n\n    // generate the message payload\n    let messagePayload = self._generateMessagePayload(message)\n\n    // iterate all connection\n    for (let i in self.api.connections.connections) {\n      self._incomingMessagePerConnection(self.api.connections.connections[ i ], messagePayload);\n    }\n  }\n\n  /**\n   * List rooms.\n   *\n   * @param callback\n   */\n  list (callback) {\n    let self = this\n\n    self.api.redis.clients.client.smembers(self.api.chatRoom.keys.rooms, (error, rooms) => {\n      if (typeof callback === 'function') { callback(error, rooms) }\n    })\n  }\n\n  /**\n   * Create a new room.\n   *\n   * @param room      Name of the room to be created.\n   * @param callback  Callback function.\n   */\n  add (room, callback) {\n    let self = this\n\n    // check if the room already exists\n    self.exists(room, (err, found) => {\n      // if the room already exists return an error\n      if (found === true) {\n        if (typeof callback === 'function') { callback(self.api.config.errors.connectionRoomExists(room), null) }\n        return\n      }\n\n      // create a new room\n      self.api.redis.clients.client.sadd(self.keys.rooms, room, (err, count) => {\n        if (typeof callback === 'function') { callback(err, count) }\n      })\n    })\n  }\n\n  /**\n   * Destroy a room.\n   *\n   * @param room      Room to be destroyed.\n   * @param callback  Callback function.\n   */\n  destroy (room, callback) {\n    let self = this\n\n    // check if the room exists\n    self.exists(room, (error, found) => {\n      // return an error if the room not exists\n      if (found === false) {\n        if (typeof callback === 'function') { callback(self.api.config.errors.connectionRoomNotExist(room), null) }\n        return\n      }\n\n      // broadcast the room destruction\n      self.broadcast({}, room, self.api.config.errors.connectionRoomHasBeenDeleted(room), () => {\n        // get all room members\n        self.api.redis.clients.client.hgetall(self.keys.members + room, (error, memberHash) => {\n          // remove each member from the room\n          for (let id in memberHash) { self.removeMember(id, room) }\n\n          // delete de room on redis server\n          self.api.redis.clients.client.srem(self.keys.rooms, room, () => {\n            if (typeof callback === 'function') { callback() }\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Check if the given room exists.\n   *\n   * @param room      Name of the room.\n   * @param callback  Callback function.\n   */\n  exists (room, callback) {\n    let self = this\n\n    // make a call to the redis server to check if the room exists\n    self.api.redis.clients.client.sismember(self.keys.rooms, room, (err, bool) => {\n      let found = false\n\n      if (bool === 1 || bool === true) { found = true }\n\n      // execute the callback\n      if (typeof callback === 'function') { callback(err, found) }\n    })\n  }\n\n  /**\n   * Get the status of a room.\n   *\n   * @param room      Name of the room to check.\n   * @param callback  Callback function.\n   */\n  roomStatus (room, callback) {\n    let self = this\n\n    // we need a room to check their status\n    if (room === undefined || room === null) {\n      if (typeof callback === 'function') { callback(self.api.config.errors.connectionRoomRequired(), null) }\n      return\n    }\n\n    // check if the room exists\n    self.exists(room, (err, found) => {\n      // the room need exists\n      if (found !== true) {\n        if (typeof callback === 'function') { callback(self.api.config.errors.connectionRoomNotExist(room), null) }\n        return\n      }\n\n      // generate the key\n      let key = self.keys.members + room\n\n      // get all channel members\n      self.api.redis.clients.client.hgetall(key, (error, members) => {\n        let cleanedMembers = {}\n        let count = 0\n\n        // iterate all members and add them to the list of members\n        for (let id in members) {\n          let data = JSON.parse(members[ id ])\n          cleanedMembers[ id ] = self._sanitizeMemberDetails(data)\n          count++\n        }\n\n        // execute the callback\n        callback(null, {\n          room: room,\n          members: cleanedMembers,\n          membersCount: count\n        })\n      })\n    })\n  }\n\n  /**\n   * Add a new member to a room.\n   *\n   * @param connectionId  Connection ID.\n   * @param room          Room name where the client must be added.\n   * @param callback      Callback function.\n   */\n  addMember (connectionId, room, callback) {\n    let self = this\n\n    // if the connection not exists create a new one in every stellar instance and return\n    if (!self.api.connections.connections[ connectionId ]) {\n      self.api.redis.doCluster('api.chatRoom.addMember', [ connectionId, room ], connectionId, callback)\n      return\n    }\n\n    // get connection object\n    let connection = self.api.connections.connections[ connectionId ]\n\n    // verifies that the connection is already within the room, if yes return now\n    if (connection.rooms.indexOf(room) > -1) {\n      if (typeof callback === 'function') { callback(self.api.config.errors.connectionAlreadyInRoom(connection, room), false) }\n      return\n    }\n\n    // check if the room exists\n    self.exists(room, (error, found) => {\n      if (found !== true) {\n        if (typeof callback === 'function') { callback(self.api.config.errors.connectionRoomNotExist(room), false) }\n        return\n      }\n\n      self._handleCallbacks(connection, room, 'join', null, error => {\n        // if exists an error, execute the callback and return\n        if (error) { return callback(error, false) }\n\n        // generate the member details\n        let memberDetails = self._generateMemberDetails(connection)\n\n        self.api.redis.clients.client.hset(self.keys.members + room, connection.id, JSON.stringify(memberDetails), () => {\n          connection.rooms.push(room)\n          if (typeof callback === 'function') { callback(null, true) }\n        })\n      })\n    })\n  }\n\n  /**\n   * Remove a client from a chat room.\n   *\n   * @param connectionId    Client connection object.\n   * @param room            Room name.\n   * @param callback        Callback.\n   */\n  removeMember (connectionId, room, callback) {\n    let self = this\n\n    // if the connection does not exists on the connections array perform a remove\n    // member on the cluster\n    if (self.api.connections.connections[ connectionId ] === undefined) {\n      self.api.redis.doCluster('api.chatRoom.removeMember', [ connectionId, room ], connectionId, callback)\n      return\n    }\n\n    let connection = self.api.connections.connections[ connectionId ]\n\n    // check if the client is connected with the room\n    if (connection.rooms.indexOf(room) < 0) {\n      if (typeof callback === 'function') { callback(self.api.config.errors.connectionNotInRoom(connection, room), false) }\n      return\n    }\n\n    // check if the room exists\n    self.exists(room, (error, found) => {\n      // if the room has not been found returned an error\n      if (found === false) {\n        if (typeof callback === 'function') { callback(self.api.config.errors.connectionRoomNotExist(room), false) }\n        return\n      }\n\n      // passes the response by the middleware\n      self._handleCallbacks(connection, room, 'leave', null, error => {\n        // execute the callback and return the error\n        if (error) { return callback(error, false) }\n\n        // remove the user\n        self.api.redis.clients.client.hdel(self.keys.members + room, connection.id, () => {\n          // get the room index\n          let index = connection.rooms.indexOf(room)\n\n          // remove room from the rooms array\n          if (index > -1) { connection.rooms.splice(index, 1) }\n\n          // execute the callback\n          if (typeof callback === 'function') { callback(null, true) }\n        })\n      })\n    })\n  }\n\n  // --------------------------------------------------------------------------------------------------------- [Private]\n\n  /**\n   * Generate a new object with member details.\n   *\n   * @param connection  Connection object.\n   * @returns {{id: *, joinedAt: number, host: *}}\n   * @private\n   */\n  _generateMemberDetails (connection) {\n    let self = this\n\n    return {\n      id: connection.id,\n      joinedAt: new Date().getTime(),\n      host: self.api.id\n    }\n  }\n\n  /**\n   * Generate a new message payload.\n   *\n   * @param message   Base message.\n   * @returns {{message: *, room: *, from: *, context: string, sendAt: *}}\n   * @private\n   */\n  _generateMessagePayload (message) {\n    return {\n      message: message.message,\n      room: message.connection.room,\n      from: message.connection.id,\n      context: 'user',\n      sentAt: message.sentAt\n    }\n  }\n\n  /**\n   * Handle the redis callbacks.\n   *\n   * This apply all global middleware for each callback response.\n   *\n   * @param connection        Connection object.\n   * @param room              Room name.\n   * @param direction         Message direction.\n   * @param messagePayload    Message payload.\n   * @param callback          Callback function.\n   * @private\n   */\n  _handleCallbacks (connection, room, direction, messagePayload, callback) {\n    let self = this\n\n    let jobs = []\n    let newMessagePayload\n\n    // if the message payload are defined create a clone\n    if (messagePayload) { newMessagePayload = Utils.objClone(messagePayload) }\n\n    // apply global middleware\n    self.globalMiddleware.forEach(name => {\n      // get middleware object\n      let m = self.middleware[ name ]\n\n      // the middleware should be a function\n      if (typeof  m[ direction ] !== 'function') { return }\n\n      // push a new job to the queue\n      jobs.push(callback => {\n        if (messagePayload) {\n          m[ direction ](connection, room, newMessagePayload, (error, data) => {\n            if (data) { newMessagePayload = data }\n            callback(error, data)\n          })\n          return\n        }\n\n        // execute the middleware without the payload\n        m[ direction ](connection, room, callback)\n      })\n    })\n\n    // execute all middleware\n    async.series(jobs, (error, data) => {\n      while (data.length > 0) {\n        let thisData = data.shift()\n\n        // change the new message object to the next middleware use it\n        if (thisData) { newMessagePayload = thisData }\n      }\n\n      // execute the next middleware\n      callback(error, newMessagePayload)\n    })\n  }\n\n  /**\n   * Sanitize member details.\n   *\n   * @param memberData                  Member details to be sanitized.\n   * @returns {{id: *, joinedAt: *}}    Sanitized\n   * @private\n   */\n  _sanitizeMemberDetails (memberData) {\n    return {\n      id: memberData.id,\n      joinedAt: memberData.joinedAt\n    }\n  }\n\n  /**\n   * Process a incoming connection for a connection object.\n   *\n   * @param connection      Connection object.\n   * @param messagePayload  Message payload to be sent.\n   * @private\n   */\n  _incomingMessagePerConnection (connection, messagePayload) {\n    let self = this\n\n    // check if the connection can chat\n    if (connection.canChat !== true) { return }\n\n    // check if the connection made part of the room\n    if (connection.rooms.indexOf(messagePayload.room) < 0) { return }\n\n    // apply the middleware\n    self._handleCallbacks(connection, messagePayload.room, 'say', messagePayload, (err, newMessagePayload) => {\n      if (!err) {\n        connection.sendMessage(newMessagePayload, 'say')\n      }\n    })\n  }\n}\n\n/**\n * Initializer.\n */\nexport default class {\n\n  /**\n   * Initializer load priority.\n   *\n   * @type {number}\n   */\n  loadPriority = 520\n\n  /**\n   * Initializer start priority.\n   *\n   * @type {number}\n   */\n  startPriority = 200\n\n  /**\n   * Initializer loading function.\n   *\n   * @param api   API reference.\n   * @param next  Callback.\n   */\n  load (api, next) {\n    // put the chat room interface available to all system\n    api.chatRoom = new ChatRooms(api)\n\n    // end the initializer loading\n    next()\n  }\n\n  /**\n   * Initializer starting function.\n   *\n   * @param api   API reference.\n   * @param next  Callback.\n   */\n  start (api, next) {\n    // subscribe new chat messages on the redis server\n    api.redis.subscriptionHandlers[ 'chat' ] = message => { api.chatRoom.incomingMessage(message) }\n\n    // check if we need to create some starting chat rooms\n    if (api.config.general.startingChatRooms) {\n      for (let room in api.config.general.startingChatRooms) {\n        api.log(`ensuring the existence of the chatRoom: ${room}`)\n        api.chatRoom.add(room)\n      }\n    }\n\n    // end the initializer starting\n    next()\n  }\n\n}\n"],"sourceRoot":"/source/"}