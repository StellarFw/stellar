{"version":3,"sources":["satellites/models.js"],"names":[],"mappings":"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","file":"satellites/models.js","sourcesContent":["import path from 'path'\nimport Utils from '../utils'\nimport mongoose from 'mongoose'\n\n/**\n * Manage the models.\n */\nclass Models {\n\n  /**\n   * Reference for the API object.\n   *\n   * @type {null}\n   */\n  api = null\n\n  /**\n   * Mongoose object.\n   *\n   * @type {null}\n   */\n  mongoose = null\n\n  /**\n   * Connection status.\n   *\n   * @type {boolean}\n   */\n  connected = false\n\n  /**\n   * Hash with all registered models.\n   *\n   * @type {Map}\n   */\n  models = new Map()\n\n  /**\n   * Create a new Models call instance.\n   *\n   * @param api   API reference.\n   */\n  constructor (api) {\n    this.api = api\n  }\n\n  /**\n   * Open connection to MongoDB server.\n   *\n   * @param callback  Callback function.\n   */\n  openConnection (callback) {\n    let self = this\n\n    // if the connection has already open return and execute the callback\n    if (self.status()) {\n      callback(new Error('Connection is already open'))\n      return\n    }\n\n    // hack: this fix a strange bug on the test environment\n    if (self.api.env === 'test' && mongoose.connections[ 0 ]._hasOpened === true) {\n      // save the mongoose instance\n      self.mongoose = mongoose\n\n      // mark mongoose was connected\n      self.connected = true\n\n      // execute the callback function and return\n      callback()\n      return\n    }\n\n    let connectCallback = () => {\n      // save mongoose object\n      self.mongoose = mongoose\n\n      // open the new connection\n      self.mongoose.connect(self.api.config.models.connectionString, (error) => {\n        if (error) {\n          self.api.log(`MongoDB Error: ${err}`, 'emerg')\n          return\n        }\n\n        self.api.log('connected to MongoDB', 'debug')\n        self.connected = true\n        callback()\n      })\n\n      // define handler for disconnected event\n      self.mongoose.connection.on('disconnected', () => {\n        self.connected = false\n        self.api.log('MongoDB Connection Closed', 'debug')\n      })\n    }\n\n    // check if we are use a mock version of the package\n    if (self.api.config.models.pkg === 'mockgoose') {\n      // require mockgoose\n      let mockgoose = require('mockgoose')\n\n      // wrap mongoose with mockgoose\n      mockgoose(mongoose).then(connectCallback)\n\n      // log an warning\n      self.api.log('running with mockgoose', 'warning')\n    } else {\n      connectCallback()\n    }\n  }\n\n  /**\n   * Close connection.\n   *\n   * @param callback  Callback function.\n   */\n  closeConnection (callback) {\n    let self = this\n\n    // if there is not connection open return now\n    if (!self.status()) {\n      callback(new Error('There is no connection open'))\n      return\n    }\n\n    self.mongoose.connection.close(callback)\n  }\n\n  /**\n   * Return the connection status.\n   *\n   * @returns {boolean}\n   */\n  status () { return this.connected }\n\n  /**\n   * Add a new model.\n   *\n   * If the model already exists it will be replaced.\n   *\n   * @param name    Model name\n   * @param schema  Model schema.\n   */\n  add (name, schema) {\n    // if the model already exists that can't be overwrite\n    if (this.models.has(name)) { return }\n\n    // save the new model instance\n    this.models.set(name, this.mongoose.model(name, schema))\n  }\n\n  /**\n   * Get a model object from the repository.\n   *\n   * @param modelName   model name to get.\n   * @returns {V}       model object.\n   */\n  get (modelName) { return this.models.get(modelName) }\n\n  /**\n   * Remove a model from the repository.\n   *\n   * @param modelName   model name to be deleted.\n   */\n  remove (modelName) { this.models.delete(modelName) }\n\n}\n\n/**\n * Initializer for the models features.\n */\nexport default class {\n\n  /**\n   * Initializer load priority.\n   *\n   * @type {number}\n   */\n  loadPriority = 100\n\n  /**\n   * Initializer start priority.\n   *\n   * @type {number}\n   */\n  startPriority = 100\n\n  /**\n   * Initializer stop priority.\n   *\n   * @type {number}\n   */\n  stopPriority = 400\n\n  /**\n   * Initializer loading function.\n   *\n   * @param api   API reference.\n   * @param next  Callback function.\n   */\n  load (api, next) {\n    // expose models class on the engine\n    api.models = new Models(api)\n\n    // finish the initializer loading\n    next()\n  }\n\n  /**\n   * Initializer start function.\n   *\n   * @param api   API reference.\n   * @param next  Callback function.\n   */\n  start (api, next) {\n    // cleanup mongoose cache\n    mongoose.models = {}\n    mongoose.modelSchemas = {}\n\n    // open connection\n    api.models.openConnection(() => {\n      // read models files from the modules\n      api.modules.modulesPaths.forEach(modulePath => {\n        Utils.recursiveDirectoryGlob(`${modulePath}/models`).forEach(moduleFile => {\n          // get file basename\n          let basename = path.basename(moduleFile, '.js')\n\n          // load the model\n          api.models.add(basename, require(moduleFile).default)\n\n          // log a message\n          api.log(`model loaded: ${basename}`, 'debug')\n        })\n      })\n\n      // finish the initializer start\n      next()\n    })\n  }\n\n  /**\n   * Initializer stop function.\n   *\n   * @param api   API reference.\n   * @param next  Callback function.\n   */\n  stop (api, next) {\n    // close connection\n    api.models.closeConnection(next)\n  }\n}\n"],"sourceRoot":"/source/"}