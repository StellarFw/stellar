{"version":3,"sources":["satellites/routes.js"],"names":[],"mappings":"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","file":"satellites/routes.js","sourcesContent":["import fs from 'fs'\nimport Utils from '../utils';\n\n/**\n * Class to manage the HTTP action routes.\n */\nclass RoutesManager {\n\n  /**\n   * API reference.\n   *\n   * @type {null}\n   */\n  api = null\n\n  /**\n   * Map with the registered routes.\n   *\n   * @type {{}}\n   */\n  routes = { 'get': [], 'post': [], 'put': [], 'patch': [], 'delete': [] }\n\n  /**\n   * Available verbs.\n   *\n   * @type {string[]}\n   */\n  verbs = [ 'get', 'post', 'put', 'patch', 'delete' ]\n\n  /**\n   * Create a new RoutesManager instance.\n   *\n   * @param api API reference.\n   */\n  constructor (api) {\n    let self = this\n\n    // save the API object reference\n    self.api = api\n  }\n\n  /**\n   * Process a route call.\n   *\n   * @param connection    Connection object.\n   * @param pathParts     URI parts.\n   */\n  processRoute (connection, pathParts) {\n    let self = this\n\n    // check if the connection contains an action and that action are defined on the current context\n    if (connection.params.action === undefined || self.api.actions.actions[ connection.params.action ] === undefined) {\n      // get HTTP request method\n      let method = connection.rawConnection.method.toLowerCase()\n\n      // if its a 'head' request change it to a 'get'\n      if (method === 'head' && !self.routes.head) { method = 'get' }\n\n      // iterate all registered routes\n      for (let i in self.routes[ method ]) {\n        let route = self.routes[ method ][ i ]\n\n        // check if exists an URL match\n        let match = self.matchURL(pathParts, route.path, route.matchTrailingPathParts);\n\n        if (match.match === true) {\n          if (route.apiVersion) {\n            connection.params.apiVersion = connection.param.apiVersion || route.apiVersion\n          }\n\n          // decode URL params\n          for (let param in match.params) {\n            try {\n              let decodedName = decodeURIComponent(param.replace(/\\+/g, ' '))\n              let decodedValue = decodeURIComponent(match.params[ param ].replace(/\\+g/, ' '))\n              connection.params[ decodedName ] = decodedValue\n            } catch (e) {\n              // malformed URL\n            }\n          }\n\n          // put the action in the connection\n          connection.params.action = route.action\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the url match with parts.\n   *\n   * @param pathParts               URL parts to check.\n   * @param match                   Route URL to check with.\n   * @param matchTrailingPathParts  Check the existence of the path in any part of the URL.\n   * @returns {{match: boolean, params: {}}}\n   */\n  matchURL (pathParts, match, matchTrailingPathParts) {\n    let response = { match: false, params: {} }\n    let matchParts = match.split('/')\n    let regexp = ''\n    let variable = ''\n\n    if (matchParts[ 0 ] === '') { matchParts.splice(0, 1) }\n\n    if (matchParts[ (matchParts.length - 1) === '' ]) { matchParts.pop() }\n\n    if (matchParts.length !== pathParts.length && matchTrailingPathParts !== true) { return response }\n\n    for (let i in matchParts) {\n      let matchPart = matchParts[ i ]\n      let pathPart = pathParts[ i ]\n\n      if (matchTrailingPathParts === true && parseInt(i) === (matchPart.len - 1)) {\n        for (let j in pathParts) {\n          if (j > i) { pathPart = `${pathPart}/${pathParts[ j ]}` }\n        }\n      }\n\n      if (!pathPart) {\n        return response\n      } else if (matchPart[ 0 ] === ':' && matchPart.indexOf('(') < 0) {\n        variable = matchPart.replace(':', '')\n        response.params[ variable ] = pathPart\n      } else if (matchPart[ 0 ] === ':' && matchPart.indexOf('(') >= 0) {\n        variable = matchPart.replace(':', '').split('(')[ 0 ]\n        regexp = matchPart.substring(matchPart.indexOf('(') + 1, matchPart.length - 1)\n        var matches = pathPart.match(new RegExp(regexp, 'g'))\n        if (matches) {\n          response.params[ variable ] = pathPart\n        } else {\n          return response\n        }\n      } else {\n        if (pathPart === null || pathPart === undefined || pathParts[ i ].toLowerCase() !== matchPart.toLowerCase()) {\n          return response\n        }\n      }\n    }\n\n    response.match = true\n\n    return response\n  }\n\n  /**\n   * Register a new route.\n   *\n   * @param method                    HTTP method\n   * @param path                      URI\n   * @param action                    Action to be executed\n   * @param apiVersion                API version\n   * @param matchTrailingPathParts\n   */\n  registerRoute (method, path, action, apiVersion, matchTrailingPathParts = false) {\n    let self = this\n\n    self.routes[ method ].push({\n      path: path,\n      matchTrailingPathParts: matchTrailingPathParts,\n      action: action,\n      apiVersion: apiVersion\n    })\n  }\n\n  /**\n   * Load routes.\n   *\n   * @param rawRoutes\n   */\n  loadRoutes (rawRoutes) {\n    let self = this\n    let counter = 0\n\n    // iterate all objects\n    for (let i in rawRoutes) {\n      // get http method in lower case\n      let method = i.toLowerCase()\n\n      for (let j in rawRoutes[ i ]) {\n        let route = rawRoutes[ i ][ j ]\n\n        if (method === 'all') {\n          // iterate all http methods\n          self.api.routes.verbs.forEach((verb) => {\n            self.api.routes.registerRoute(verb, route.path, route.action, route.apiVersion, route.matchTrailingPathParts)\n          })\n        } else {\n          self.api.routes.registerRoute(method, route.path, route.action, route.apiVersion, route.matchTrailingPathParts)\n        }\n        counter++\n      }\n    }\n\n    // remove duplicated entries on postVariables\n    self.api.params.postVariables = Utils.arrayUniqueify(self.api.params.postVariables)\n\n    // log the number of loaded routes\n    self.api.log(`${counter} routes loaded`, 'debug')\n\n    if (self.api.config.servers.web && self.api.config.servers.web.simpleRouting === true) {\n      let simplePaths = []\n\n      // iterate all registered actions\n      for (let action in self.api.actions.actions) {\n        // push the action name to the simples paths\n        simplePaths.push(`/${action}`)\n\n        // iterate all verbs\n        self.verbs.forEach(verb => { self.registerRoute(verb, `/${action}`, action) })\n      }\n\n      // log the number of simple routes loaded\n      self.api.log(`${simplePaths.length} simple routes loaded from action names`, 'debug')\n      self.api.log('routes: ', 'debug', self.routes)\n    }\n  }\n\n  /**\n   * Load all modules route files.\n   *\n   * If the modules have the 'routes.js' file on the module root\n   * folder we load that file.\n   */\n  loadModulesRoutes () {\n    let self = this\n\n    // iterate all active modules\n    self.api.modules.modulesPaths.forEach(modulePath => {\n      try {\n        // build the file path\n        let path = `${modulePath}/routes.json`\n\n        // check if the module have a 'routes.js' file\n        fs.accessSync(path, fs.F_OK)\n\n        // load the routes on the engine\n        self.loadRoutes(require(path))\n      } catch (e) {\n        // do nothing\n      }\n    })\n\n    // check if we have some routes on the config object\n    if (self.api.config.routes) { self.loadRoutes(self.api.config.routes) }\n  }\n}\n\n/**\n * Initializer to load the class who process the routes requests.\n */\nexport default class {\n\n  /**\n   * Initializer load priority.\n   *\n   * This only can be loaded after the servers.\n   *\n   * @type {number}\n   */\n  loadPriority = 500\n\n  /**\n   * Initializer loading function.\n   *\n   * @param api   API reference.\n   * @param next  Callback function.\n   */\n  load (api, next) {\n    // put the routes manager available to all platform\n    api.routes = new RoutesManager(api)\n\n    // load routes from the config file\n    api.routes.loadModulesRoutes()\n\n    // finish the initializer loading\n    next()\n  }\n\n}\n"],"sourceRoot":"/source/"}