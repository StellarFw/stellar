{"version":3,"sources":["satellites/cache.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;;;;;;;;;IAOM,Y;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDJ,wBAAa,GAAb,EAAkB;AAAA;;AAAA,SA1ClB,GA0CkB,GA1CZ,IA0CY;AAAA,SAnClB,WAmCkB,GAnCJ,IAmCI;AAAA,SA5BlB,UA4BkB,GA5BL,IA4BK;AAAA,SArBlB,YAqBkB,GArBH,IAqBG;AAAA,SAdlB,QAckB,GAdP,IAcO;AAAA,SAPlB,SAOkB,GAPN,GAOM;;AAChB,SAAK,GAAL,GAAW,GAAX;;AAEA,SAAK,WAAL,GAAmB,IAAI,MAAJ,CAAW,OAAX,CAAmB,WAAtC;AACA,SAAK,UAAL,GAAkB,IAAI,MAAJ,CAAW,OAAX,CAAmB,UAArC;AACA,SAAK,YAAL,GAAoB,IAAI,MAAJ,CAAW,OAAX,CAAmB,YAAvC;AACA,SAAK,QAAL,GAAgB,IAAI,EAApB;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yBASK,I,EAAM;AACV,UAAI,OAAO,IAAX;AACA,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,IAA9B,CAAmC,KAAK,WAAL,GAAmB,GAAtD,EAA2D,UAAC,GAAD,EAAM,IAAN,EAAe;AAAE,aAAK,GAAL,EAAU,IAAV;AAAkB,OAA9F;AACD;;;;;;;;;;yBAOK,I,EAAM;AACV,UAAI,OAAO,IAAX;;;AAGA,WAAK,IAAL,CAAU,UAAC,GAAD,EAAM,IAAN,EAAe;AACvB,YAAI,SAAS,CAAb;;;AAGA,YAAI,IAAJ,EAAU;AAAE,mBAAS,KAAK,MAAd;AAAuB;;AAEnC,aAAK,GAAL,EAAU,MAAV;AACD,OAPD;AAQD;;;;;;;;;;0BAOM,Q,EAAU;AACf,UAAI,OAAO,IAAX;;;AAGA,WAAK,IAAL,CAAU,UAAC,GAAD,EAAM,IAAN,EAAe;AACvB,YAAI,OAAO,OAAO,QAAP,KAAoB,UAA/B,EAA2C;AAAE,iBAAO,SAAS,KAAT,CAAP;AAAwB;;;AAGrE,YAAI,OAAO,EAAX;;;AAGA,aAAK,OAAL,CAAa;AAAA,iBAAO,KAAK,IAAL,CAAU;AAAA,mBAAQ,KAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,GAAlC,EAAuC,IAAvC,CAAR;AAAA,WAAV,CAAP;AAAA,SAAb;;;AAGA,wBAAM,QAAN,CAAe,IAAf,EAAqB,iBAAS;AAC5B,cAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAAE,mBAAO,SAAS,KAAT,CAAP;AAAwB;AAC/D,SAFD;AAGD,OAbD;AAcD;;;;;;;;;;;;;yBAUK,G,EAAK,K,EAAO,Y,EAAc,Q,EAAU;AACxC,UAAI,OAAO,IAAX;;AAEA,UAAI,OAAO,YAAP,KAAwB,UAAxB,IAAsC,OAAO,QAAP,KAAoB,WAA9D,EAA2E;AACzE,mBAAW,YAAX;AACA,uBAAe,IAAf;AACD;;AAED,UAAI,oBAAoB,IAAxB;AACA,UAAI,kBAAkB,IAAtB;;;;AAIA,UAAI,iBAAiB,IAArB,EAA2B;AACzB,4BAAoB,KAAK,IAAL,CAAU,eAAe,IAAzB,CAApB;AACA,0BAAkB,IAAI,IAAJ,GAAW,OAAX,KAAuB,YAAzC;AACD;;;AAGD,UAAI,WAAW;AACb,eAAO,KADM;AAEb,yBAAiB,eAFJ;AAGb,mBAAW,IAAI,IAAJ,GAAW,OAAX,EAHE;AAIb,gBAAQ;AAJK,OAAf;;;AAQA,WAAK,SAAL,CAAe,GAAf,EAAoB,IAApB,EAA0B,UAAC,KAAD,EAAQ,MAAR,EAAmB;AAC3C,YAAI,SAAS,WAAW,IAAxB,EAA8B;AAC5B,cAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAAE,qBAAS,IAAI,KAAJ,CAAU,eAAV,CAAT;AAAsC;AAC7E,SAFD,MAEO;AAAA;;AAEL,gBAAI,YAAY,KAAK,WAAL,GAAmB,GAAnC;AACA,iBAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,SAAlC,EAA6C,KAAK,SAAL,CAAe,QAAf,CAA7C,EAAuE,UAAC,GAAD,EAAS;;AAE9E,kBAAI,QAAQ,IAAR,IAAgB,iBAApB,EAAuC;AAAE,qBAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,MAA9B,CAAqC,SAArC,EAAgD,iBAAhD;AAAoE;;;AAG7G,kBAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAAE,wBAAQ,QAAR,CAAiB,YAAM;AAAE,2BAAS,GAAT,EAAc,IAAd;AAAqB,iBAA9C;AAAiD;AACxF,aAND;AAHK;AAUN;AACF,OAdD;AAeD;;;;;;;;;;;;yBASK,G,EAAK,O,EAAS,I,EAAM;AACxB,UAAI,OAAO,IAAX;;AAEA,UAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,eAAO,OAAP;AACA,kBAAU,EAAV;AACD;;;AAGD,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,KAAK,WAAL,GAAmB,GAArD,EAA0D,UAAC,GAAD,EAAM,QAAN,EAAmB;;AAE3E,YAAI,GAAJ,EAAS;AAAE,eAAK,GAAL,CAAS,GAAT,CAAa,GAAb,EAAkB,OAAlB;AAA6B;;;AAGxC,YAAI;AAAE,qBAAW,KAAK,KAAL,CAAW,QAAX,CAAX;AAAkC,SAAxC,CAAyC,OAAO,CAAP,EAAU,CAAE;;;AAGrD,YAAI,CAAC,QAAL,EAAe;AACb,cAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC9B,oBAAQ,QAAR,CAAiB,YAAM;AAAE,mBAAK,IAAI,KAAJ,CAAU,kBAAV,CAAL,EAAoC,IAApC,EAA0C,IAA1C,EAAgD,IAAhD,EAAsD,IAAtD;AAA8D,aAAvF;AACD;AACF,SAJD,MAIO,IAAI,SAAS,eAAT,IAA4B,IAAI,IAAJ,GAAW,OAAX,EAA5B,IAAoD,SAAS,eAAT,KAA6B,IAArF,EAA2F;AAAA;AAChG,gBAAI,aAAa,SAAS,MAA1B;AACA,gBAAI,0BAAJ;;;AAGA,qBAAS,MAAT,GAAkB,IAAI,IAAJ,GAAW,OAAX,EAAlB;;AAEA,gBAAI,SAAS,eAAb,EAA8B;;AAE5B,kBAAI,QAAQ,YAAZ,EAA0B;AACxB,yBAAS,eAAT,GAA2B,IAAI,IAAJ,GAAW,OAAX,KAAuB,QAAQ,YAA1D;AACA,oCAAoB,KAAK,IAAL,CAAU,QAAQ,YAAR,GAAuB,IAAjC,CAApB;AACD,eAHD,MAGO;AACL,oCAAoB,KAAK,KAAL,CAAW,CAAC,SAAS,eAAT,GAA2B,IAAI,IAAJ,GAAW,OAAX,EAA5B,IAAoD,IAA/D,CAApB;AACD;AACF;;;AAGD,iBAAK,SAAL,CAAe,GAAf,EAAoB,QAAQ,KAA5B,EAAmC,UAAC,GAAD,EAAM,MAAN,EAAiB;AAClD,kBAAI,OAAO,WAAW,IAAtB,EAA4B;AAC1B,oBAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAAE,uBAAK,IAAI,KAAJ,CAAU,eAAV,CAAL;AAAmC;AACtE,eAFD,MAEO;AACL,qBAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,KAAK,WAAL,GAAmB,GAArD,EAA0D,KAAK,SAAL,CAAe,QAAf,CAA1D,EAAoF,UAAC,GAAD,EAAS;AAC3F,sBAAI,OAAO,iBAAP,KAA6B,QAAjC,EAA2C;AACzC,yBAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,MAA9B,CAAqC,KAAK,WAAL,GAAmB,GAAxD,EAA6D,iBAA7D;AACD;AACD,sBAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC9B,4BAAQ,QAAR,CAAiB,YAAY;AAAE,2BAAK,GAAL,EAAU,SAAS,KAAnB,EAA0B,SAAS,eAAnC,EAAoD,SAAS,SAA7D,EAAwE,UAAxE;AAAsF,qBAArH;AACD;AACF,iBAPD;AAQD;AACF,aAbD;AAlBgG;AAgCjG,SAhCM,MAgCA;AACL,cAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC9B,oBAAQ,QAAR,CAAiB,YAAM;AAAE,mBAAK,IAAI,KAAJ,CAAU,gBAAV,CAAL,EAAkC,IAAlC,EAAwC,IAAxC,EAA8C,IAA9C,EAAoD,IAApD;AAA4D,aAArF;AACD;AACF;AACF,OAjDD;AAkDD;;;;;;;;;;;4BAQQ,G,EAAK,I,EAAM;AAClB,UAAI,OAAO,IAAX;;;AAGA,WAAK,SAAL,CAAe,GAAf,EAAoB,IAApB,EAA0B,UAAC,GAAD,EAAM,MAAN,EAAiB;AACzC,YAAI,OAAO,WAAW,IAAtB,EAA4B;AAC1B,cAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAAE,iBAAK,IAAI,KAAJ,CAAU,eAAV,CAAL;AAAmC;AACtE,SAFD,MAEO;AACL,eAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,KAAK,WAAL,GAAmB,GAArD,EAA0D,UAAC,GAAD,EAAM,KAAN,EAAgB;AACxE,gBAAI,GAAJ,EAAS;AAAE,mBAAK,GAAL,CAAS,GAAT,CAAa,GAAb,EAAkB,OAAlB;AAA6B;AACxC,gBAAI,OAAO,IAAX;AACA,gBAAI,UAAU,CAAd,EAAiB;AAAE,qBAAO,KAAP;AAAe;AAClC,gBAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAAE,mBAAK,IAAL,EAAW,IAAX;AAAmB;AACtD,WALD;AAMD;AACF,OAXD;AAYD;;;;;;;;;;;;0BASM,I,EAAM;AACX,UAAI,OAAO,IAAX;AACA,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,IAA9B,CAAmC,KAAK,UAAL,GAAkB,GAArD,EAA0D,UAAC,GAAD,EAAM,IAAN,EAAe;AAAE,aAAK,GAAL,EAAU,IAAV;AAAkB,OAA7F;AACD;;;;;;;;;;;;yBASK,G,EAAK,Y,EAAc,Q,EAAU;AACjC,UAAI,OAAO,IAAX;;;AAGA,UAAI,OAAO,YAAP,KAAwB,UAAxB,IAAsC,aAAa,IAAvD,EAA6D;AAC3D,mBAAW,YAAX;AACA,uBAAe,IAAf;AACD;;;AAGD,UAAI,iBAAiB,IAArB,EAA2B;AAAE,uBAAe,KAAK,YAApB;AAAkC;;;AAG/D,WAAK,SAAL,CAAe,GAAf,EAAoB,IAApB,EAA0B,UAAC,KAAD,EAAQ,IAAR,EAAiB;;AAEzC,YAAI,SAAS,SAAS,IAAtB,EAA4B;AAAE,iBAAO,SAAS,KAAT,EAAgB,KAAhB,CAAP;AAA+B;;;AAG7D,YAAI,UAAU,KAAK,UAAL,GAAkB,GAAhC;AACA,aAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,KAA9B,CAAoC,OAApC,EAA6C,KAAK,QAAlD,EAA4D,iBAAS;;AAEnE,cAAI,KAAJ,EAAW;AAAE,mBAAO,SAAS,KAAT,CAAP;AAAwB;;;AAGrC,eAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,MAA9B,CAAqC,OAArC,EAA8C,KAAK,IAAL,CAAU,eAAe,IAAzB,CAA9C,EAA8E,iBAAS;AACrF,mBAAO,CAAC,KAAR;AACA,mBAAO,SAAS,KAAT,EAAgB,IAAhB,CAAP;AACD,WAHD;AAID,SATD;AAUD,OAhBD;AAiBD;;;;;;;;;;;2BAQO,G,EAAK,Q,EAAU;AACrB,UAAI,OAAO,IAAX;;;AAGA,WAAK,SAAL,CAAe,GAAf,EAAoB,IAApB,EAA0B,UAAC,KAAD,EAAQ,IAAR,EAAiB;AACzC,YAAI,SAAS,SAAS,IAAtB,EAA4B;AAAE,iBAAO,SAAS,KAAT,EAAgB,KAAhB,CAAP;AAA+B;;;AAG7D,aAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,KAAK,UAAL,GAAkB,GAApD,EAAyD,iBAAS;AAChE,iBAAO,IAAP;AACA,cAAI,KAAJ,EAAW;AAAE,mBAAO,KAAP;AAAc;AAC3B,iBAAO,SAAS,KAAT,EAAgB,IAAhB,CAAP;AACD,SAJD;AAKD,OATD;AAUD;;;;;;;;;;;;;8BAUU,G,EAAK,K,EAAO,Q,EAAU,S,EAAW;AAC1C,UAAI,OAAO,IAAX;;;AAGA,UAAI,cAAc,IAAlB,EAAwB;AAAE,oBAAY,IAAI,IAAJ,GAAW,OAAX,EAAZ;AAAkC;;;AAG5D,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,GAA9B,CAAkC,KAAK,UAAL,GAAkB,GAApD,EAAyD,UAAC,KAAD,EAAQ,QAAR,EAAqB;AAC5E,YAAI,KAAJ,EAAW;AACT,iBAAO,SAAS,KAAT,EAAgB,KAAhB,CAAP;AACD,SAFD,MAEO,IAAI,aAAa,KAAK,QAAlB,IAA8B,aAAa,IAA/C,EAAqD;AAC1D,iBAAO,SAAS,IAAT,EAAe,IAAf,CAAP;AACD,SAFM,MAEA;;AAEL,cAAI,QAAQ,IAAI,IAAJ,GAAW,OAAX,KAAuB,SAAnC;;AAEA,cAAI,UAAU,IAAV,IAAkB,UAAU,KAA5B,IAAqC,QAAQ,KAAjD,EAAwD;AAAE,mBAAO,SAAS,IAAT,EAAe,KAAf,CAAP;AAA8B;;AAExF,iBAAO,WAAW,YAAM;AACtB,iBAAK,SAAL,CAAe,GAAf,EAAoB,KAApB,EAA2B,QAA3B,EAAqC,SAArC;AACD,WAFM,EAEJ,KAAK,SAFD,CAAP;AAGD;AACF,OAfD;AAgBD;;;;;;;;;;;;;;yBAWK,G,EAAK,I,EAAM,Q,EAAU;AACzB,UAAI,OAAO,IAAX;;;AAGA,UAAI,SAAS,KAAK,SAAL,CAAe,EAAC,MAAM,IAAP,EAAf,CAAb;;;AAGA,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,KAA9B,CAAoC,KAAK,WAAL,GAAmB,GAAvD,EAA4D,MAA5D,EAAoE,iBAAS;AAC3E,YAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAAE,mBAAS,KAAT;AAAiB;AACxD,OAFD;AAGD;;;;;;;;;;;;;wBAUI,G,EAAK,Q,EAAU;AAClB,UAAI,OAAO,IAAX;;;AAGA,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,IAA9B,CAAmC,KAAK,WAAL,GAAmB,GAAtD,EAA2D,UAAC,KAAD,EAAQ,MAAR,EAAmB;;AAE5E,YAAI,KAAJ,EAAW;AAAE,iBAAO,SAAS,KAAT,CAAP;AAAwB;;;AAGrC,YAAI,CAAC,MAAL,EAAa;AAAE,iBAAO,UAAP;AAAmB;;;AAGlC,YAAI,OAAO,IAAX;;AAEA,YAAI;AACF,iBAAO,KAAK,KAAL,CAAW,MAAX,CAAP;AACD,SAFD,CAEE,OAAO,CAAP,EAAU;AACV,iBAAO,SAAS,KAAT,CAAP;AACD;;;AAGD,eAAO,SAAS,IAAT,EAAe,KAAK,IAApB,CAAP;AACD,OAlBD;AAmBD;;;;;;;;;;;+BAQW,G,EAAK,Q,EAAU;AACzB,UAAI,OAAO,IAAX;;;AAGA,WAAK,GAAL,CAAS,KAAT,CAAe,OAAf,CAAuB,MAAvB,CAA8B,IAA9B,CAAmC,KAAK,WAAL,GAAmB,GAAtD,EAA2D,QAA3D;AACD;;;;;;;;;;;;;;;SAaD,Y,GAAe,G;;;;;;;;;;;;;;;;;;;;yBAQT,G,EAAK,I,EAAM;;AAEf,UAAI,KAAJ,GAAY,IAAI,YAAJ,CAAiB,GAAjB,CAAZ;;;AAGA;AACD","file":"satellites/cache.js","sourcesContent":["import async from 'async'\n\n/**\n * Cache manager class.\n *\n * This class provides an easy way for developers to make use of a cache system.\n */\nclass CacheManager {\n\n  /**\n   * API reference.\n   *\n   * @type {null}\n   */\n  api = null;\n\n  /**\n   * Cache key prefix.\n   *\n   * @type {String}\n   */\n  redisPrefix = null;\n\n  /**\n   * Lock key prefix.\n   *\n   * @type {String}\n   */\n  lockPrefix = null;\n\n  /**\n   * Lock duration.\n   *\n   * @type {Number}\n   */\n  lockDuration = null;\n\n  /**\n   * Lock name.\n   *\n   * @type {String}\n   */\n  lockName = null;\n\n  /**\n   * Lock interval to retry.\n   *\n   * @type {Number}\n   */\n  lockRetry = 100;\n\n  /**\n   * Constructor.\n   *\n   * @param api API reference.\n   */\n  constructor (api) {\n    this.api = api;\n\n    this.redisPrefix = api.config.general.cachePrefix;\n    this.lockPrefix = api.config.general.lockPrefix;\n    this.lockDuration = api.config.general.lockDuration;\n    this.lockName = api.id;\n  }\n\n  // ----------------------------------------------------------------------------------------------------------- [Basic]\n\n  /**\n   * Get all cached keys.\n   *\n   * @param next  Callback.\n   */\n  keys (next) {\n    let self = this;\n    self.api.redis.clients.client.keys(this.redisPrefix + '*', (err, keys) => { next(err, keys); });\n  }\n\n  /**\n   * Get the total number of cached items.\n   *\n   * @param next  Callback.\n   */\n  size (next) {\n    let self = this;\n\n    // get all cached keys\n    self.keys((err, keys) => {\n      let length = 0;\n\n      // get the keys length if present\n      if (keys) { length = keys.length; }\n\n      next(err, length);\n    });\n  }\n\n  /**\n   * Remove all cached items.\n   *\n   * @param next  Callback.\n   */\n  clear (callback) {\n    let self = this\n\n    // get all cached keys\n    self.keys((err, keys) => {\n      if (err && typeof callback === 'function') { return callback(error) }\n\n      // array with the jobs to be done\n      let jobs = []\n\n      // iterate all keys and push a new jobs for the array\n      keys.forEach(key => jobs.push(done => self.api.redis.clients.client.del(key, done)))\n\n      // execute all the jobs, this can be done in parallel\n      async.parallel(jobs, error => {\n        if (typeof callback === 'function') { return callback(error) }\n      })\n    })\n  }\n\n  /**\n   * Save a new cache entry.\n   *\n   * @param key           Key to be saved.\n   * @param value         Value to associate with the key.\n   * @param expireTimeMS  Expire time in milliseconds.\n   * @param callback      Callback function.\n   */\n  save (key, value, expireTimeMS, callback) {\n    let self = this\n\n    if (typeof expireTimeMS === 'function' && typeof callback === 'undefined') {\n      callback = expireTimeMS\n      expireTimeMS = null\n    }\n\n    let expireTimeSeconds = null\n    let expireTimestamp = null\n\n    // if expireTimeMS is different than null we calculate the expire time in seconds\n    // and the expire timestamp\n    if (expireTimeMS !== null) {\n      expireTimeSeconds = Math.ceil(expireTimeMS / 1000)\n      expireTimestamp = new Date().getTime() + expireTimeMS\n    }\n\n    // build the cache object\n    let cacheObj = {\n      value: value,\n      expireTimestamp: expireTimestamp,\n      createdAt: new Date().getTime(),\n      readAt: null\n    }\n\n    // check if the key are locked\n    self.checkLock(key, null, (error, lockOk) => {\n      if (error || lockOk !== true) {\n        if (typeof callback === 'function') { callback(new Error('Object locked')) }\n      } else {\n        // save the new key and value\n        let keyToSave = self.redisPrefix + key\n        self.api.redis.clients.client.set(keyToSave, JSON.stringify(cacheObj), (err) => {\n          // if the new cache entry has been saved define the expire date if needed\n          if (err === null && expireTimeSeconds) { self.api.redis.clients.client.expire(keyToSave, expireTimeSeconds) }\n\n          // execute the callback\n          if (typeof callback === 'function') { process.nextTick(() => { callback(err, true) }) }\n        });\n      }\n    });\n  }\n\n  /**\n   * Get a cache entry by their key.\n   *\n   * @param key       Key to search.\n   * @param options   Call options.\n   * @param next      Callback function.\n   */\n  load (key, options, next) {\n    let self = this;\n\n    if (typeof options === 'function') {\n      next = options;\n      options = {};\n    }\n\n    // get the cache entry from redis server\n    self.api.redis.clients.client.get(self.redisPrefix + key, (err, cacheObj) => {\n      // log the error if exists\n      if (err) { self.api.log(err, 'error'); }\n\n      // try parse the redis response\n      try { cacheObj = JSON.parse(cacheObj); } catch (e) {}\n\n      // check if the object exist\n      if (!cacheObj) {\n        if (typeof next === 'function') {\n          process.nextTick(() => { next(new Error('Object not found'), null, null, null, null); })\n        }\n      } else if (cacheObj.expireTimestamp >= new Date().getTime() || cacheObj.expireTimestamp === null) {\n        let lastReadAt = cacheObj.readAt;\n        let expireTimeSeconds;\n\n        // update the readAt property\n        cacheObj.readAt = new Date().getTime();\n\n        if (cacheObj.expireTimestamp) {\n          // define the new expire time if requested\n          if (options.expireTimeMS) {\n            cacheObj.expireTimestamp = new Date().getTime() + options.expireTimeMS\n            expireTimeSeconds = Math.ceil(options.expireTimeMS / 1000);\n          } else {\n            expireTimeSeconds = Math.floor((cacheObj.expireTimestamp - new Date().getTime()) / 1000);\n          }\n        }\n\n        // check the cache entry lock\n        self.checkLock(key, options.retry, (err, lockOk) => {\n          if (err || lockOk !== true) {\n            if (typeof next === 'function') { next(new Error('Object locked')); }\n          } else {\n            self.api.redis.clients.client.set(self.redisPrefix + key, JSON.stringify(cacheObj), (err) => {\n              if (typeof expireTimeSeconds === 'number') {\n                self.api.redis.clients.client.expire(self.redisPrefix + key, expireTimeSeconds);\n              }\n              if (typeof next === 'function') {\n                process.nextTick(function () { next(err, cacheObj.value, cacheObj.expireTimestamp, cacheObj.createdAt, lastReadAt); });\n              }\n            });\n          }\n        });\n      } else {\n        if (typeof next === 'function') {\n          process.nextTick(() => { next(new Error('Object expired'), null, null, null, null); });\n        }\n      }\n    });\n  }\n\n  /**\n   * Destroy a cache entry.\n   *\n   * @param key   Key to destroy.\n   * @param next  Callback.\n   */\n  destroy (key, next) {\n    let self = this;\n\n    // check cache entry lock\n    self.checkLock(key, null, (err, lockOk) => {\n      if (err || lockOk !== true) {\n        if (typeof next === 'function') { next(new Error('Object locked')); }\n      } else {\n        self.api.redis.clients.client.del(self.redisPrefix + key, (err, count) => {\n          if (err) { self.api.log(err, 'error'); }\n          let resp = true;\n          if (count !== 1) { resp = false; }\n          if (typeof next === 'function') { next(null, resp); }\n        });\n      }\n    });\n  }\n\n  // ------------------------------------------------------------------------------------------------------------ [Lock]\n\n  /**\n   * Get all existing locks.\n   *\n   * @param next Callback function.\n   */\n  locks (next) {\n    let self = this;\n    self.api.redis.clients.client.keys(this.lockPrefix + '*', (err, keys) => { next(err, keys); });\n  }\n\n  /**\n   * Lock a cache entry.\n   *\n   * @param key           Key to lock.\n   * @param expireTimeMS  Expire time (optional)\n   * @param callback      Callback function.\n   */\n  lock (key, expireTimeMS, callback) {\n    let self = this\n\n    // if the expireTimeMS is a function that means the developer don't set a expire time\n    if (typeof expireTimeMS === 'function' && callback === null) {\n      callback = expireTimeMS\n      expireTimeMS = null\n    }\n\n    // assign the default expire time if the expireTimeMS is equals to null\n    if (expireTimeMS === null) { expireTimeMS = self.lockDuration }\n\n    // check the lock state\n    self.checkLock(key, null, (error, lock) => {\n      // if there is an error or the lock already exists\n      if (error || lock !== true) { return callback(error, false) }\n\n      // create a new lock\n      let lockKey = self.lockPrefix + key\n      self.api.redis.clients.client.setnx(lockKey, self.lockName, error => {\n        // return the error if exists\n        if (error) { return callback(error) }\n\n        // set an expire date for the lock\n        self.api.redis.clients.client.expire(lockKey, Math.ceil(expireTimeMS / 1000), error => {\n          lock = !error;\n          return callback(error, lock)\n        })\n      })\n    })\n  }\n\n  /**\n   * Unlock a cache entry.\n   *\n   * @param key       Key to unlock.\n   * @param callback  Callback function.\n   */\n  unlock (key, callback) {\n    let self = this\n\n    // check the lock state, if already unlocked returns.\n    self.checkLock(key, null, (error, lock) => {\n      if (error || lock !== true) { return callback(error, false) }\n\n      // remove the lock\n      self.api.redis.clients.client.del(self.lockPrefix + key, error => {\n        lock = true\n        if (error) { lock = false }\n        return callback(error, lock)\n      })\n    })\n  }\n\n  /**\n   * Check if a cache entry is locked.\n   *\n   * @param key       Key to check.\n   * @param retry     If defined keep retrying until the lock is free to be re-obtained.\n   * @param callback      Callback function.\n   * @param startTime This should not be used by the user.\n   */\n  checkLock (key, retry, callback, startTime) {\n    let self = this\n\n    // if the start time are not defined use the current timestamp\n    if (startTime === null) { startTime = new Date().getTime() }\n\n    // get the cache entry\n    self.api.redis.clients.client.get(self.lockPrefix + key, (error, lockedBy) => {\n      if (error) {\n        return callback(error, false)\n      } else if (lockedBy === self.lockName || lockedBy === null) {\n        return callback(null, true)\n      } else {\n        // calculate the time variation between the request and the response\n        let delta = new Date().getTime() - startTime;\n\n        if (retry === null || retry === false || delta > retry) { return callback(null, false) }\n\n        return setTimeout(() => {\n          self.checkLock(key, retry, callback, startTime)\n        }, self.lockRetry)\n      }\n    })\n  }\n\n  // ------------------------------------------------------------------------------------------------------------ [List]\n\n  /**\n   * Push a new object to a list.\n   *\n   * @param key       List key.\n   * @param item      Item to cache.\n   * @param callback  Callback function.\n   */\n  push (key, item, callback) {\n    let self = this\n\n    // stringify the data to save\n    let object = JSON.stringify({data: item})\n\n    // push the new item to Redis\n    self.api.redis.clients.client.rpush(self.redisPrefix + key, object, error => {\n      if (typeof callback === 'function') { callback(error) }\n    })\n  }\n\n  /**\n   * Pop a value from a list.\n   *\n   * If the key not exists a null value will be returned.\n   *\n   * @param key       Key to search for.\n   * @param callback  Callback function.\n   */\n  pop (key, callback) {\n    let self = this\n\n    // pop the item from Redis\n    self.api.redis.clients.client.lpop(self.redisPrefix + key, (error, object) => {\n      // check if an error occurred during the request\n      if (error) { return callback(error) }\n\n      // if the object not exist return null\n      if (!object) { return callback() }\n\n      // try parse the item and return it\n      let item = null\n\n      try {\n        item = JSON.parse(object)\n      } catch (e) {\n        return callback(error)\n      }\n\n      // return the parsed object\n      return callback(null, item.data)\n    })\n  }\n\n  /**\n   * Get the length of the list.\n   *\n   * @param key       Key to search for.\n   * @param callback  Callback function.\n   */\n  listLength (key, callback) {\n    let self = this\n\n    // request the list's length to Redis\n    self.api.redis.clients.client.llen(self.redisPrefix + key, callback)\n  }\n}\n\n/**\n * Cache initializer.\n */\nexport default class {\n\n  /**\n   * Initializer load priority\n   *\n   * @type {number}\n   */\n  loadPriority = 300\n\n  /**\n   * Initializer load method.\n   *\n   * @param api\n   * @param next\n   */\n  load (api, next) {\n    // put cache manager available to all API\n    api.cache = new CacheManager(api)\n\n    // finish the initializer loading\n    next()\n  }\n\n}\n"],"sourceRoot":"/source/"}