{"version":3,"sources":["servers/tcp.js"],"names":[],"mappings":"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","file":"servers/tcp.js","sourcesContent":["import net from 'net'\nimport tls from 'tls'\nimport GenericServer from '../genericServer'\n\n// server type\nlet type = 'tcp'\n\n// server attributes\nlet attributes = {\n  canChat: true,\n  logConnections: true,\n  logExits: true,\n  pendingShutdownWaitLimit: 5000,\n  sendWelcomeMessage: true,\n  verbs: [\n    'quit',\n    'exit',\n    'paramAdd',\n    'paramDelete',\n    'paramView',\n    'paramsView',\n    'paramsDelete',\n    'roomAdd',\n    'roomLeave',\n    'roomView',\n    'detailsView',\n    'say'\n  ]\n}\n\n/**\n * TCP server implementation.\n */\nexport default class Tcp extends GenericServer {\n\n  /**\n   * TCP server socket.\n   */\n  server = null\n\n  /**\n   * Create a new server instance.\n   *\n   * @param api       API object reference.\n   * @param options   Server options.\n   */\n  constructor (api, options) {\n    // call super constructor\n    super(api, type, options, attributes)\n\n    // define events\n    this._defineEvents()\n  }\n\n  // ------------------------------------------------------------------------------------------------ [Required Methods]\n\n  /**\n   * Start server.\n   *\n   * @param callback callback\n   */\n  start (callback) {\n    let self = this\n\n    if (self.options.secure === false) {\n      self.server = net.createServer(self.api.config.servers.tcp.serverOptions, rawConnection => {\n        self._handleConnection(rawConnection)\n      })\n    } else {\n      self.server = tls.createServer(self.api.config.servers.tcp.serverOptions, rawConnection => {\n        self._handleConnection(rawConnection)\n      })\n    }\n\n    // on server error\n    self.server.on('error', e => {\n      return callback(new Error(`Cannot start tcp server @ ${self.options.bindIP}:${self.options.port} => ${e.message}`))\n    })\n\n    // server listener\n    self.server.listen(self.options.port, self.options.bindIP, () => { process.nextTick(callback) })\n  }\n\n  /**\n   * Stop server.\n   *\n   * @param next\n   */\n  stop (next) { this._gracefulShutdown(next) }\n\n  /**\n   * Send a message to a client.\n   *\n   * @param connection    Client connection object.\n   * @param message       Message to be sent.\n   * @param messageCount  Number of messages already sent for this client.\n   */\n  sendMessage (connection, message, messageCount) {\n    let self = this\n\n    // if is an error message serialize the object\n    if (message.error) {\n      message.error = self.api.config.errors.serializers.servers.tcp(message.error)\n    }\n\n    if (connection.respondingTo) {\n      message.messageCount = messageCount\n      connection.respondingTo = null\n    } else if (message.context === 'response') {\n      // if the messageCount isn't defined use the connection.messageCount\n      if (messageCount) {\n        message.messageCount = messageCount\n      } else {\n        message.messageCount = connection.messageCount\n      }\n    }\n\n    // try send the message to the client\n    try {\n      connection.rawConnection.write(JSON.stringify(message) + '\\r\\n')\n    } catch (e) {\n      self.api.log(`socket write error: ${e}`, 'error')\n    }\n  }\n\n  /**\n   * Close the connection with the client sending a 'Bye!' message.\n   *\n   * @param connection  Client connection.\n   */\n  goodbye (connection) {\n    let self = this\n\n    try {\n      connection.rawConnection.end(JSON.stringify({\n          status: connection.localize(self.api.config.servers.tcp.goodbeyMessage),\n          context: 'api'\n        }) + '\\r\\n')\n    } catch (e) {}\n  }\n\n  /**\n   * Send a file to the client.\n   *\n   * If the error is defined send a error message instead.\n   *\n   * @param connection  Client connection object.\n   * @param error       Error object.\n   * @param fileStream  FileStream object.\n   */\n  sendFile (connection, error, fileStream) {\n    let self = this\n\n    // if is an error response send a message with the error\n    if (error) {\n      self.server.sendMessage(connection, error, connection.messageCount)\n    } else {\n      // send the file to client\n      fileStream.pipe(connection.rawConnection, {end: false})\n    }\n  }\n\n  // ---------------------------------------------------------------------------------------------------------- [Events]\n\n  /**\n   * Define server events.\n   *\n   * @private\n   */\n  _defineEvents () {\n    let self = this\n\n    // on connection event\n    self.on('connection', connection => {\n      connection.params = {}\n\n      let parseLine = line => {\n        // check the message length if the maxDataLength is active\n        if (self.api.config.servers.tcp.maxDataLength > 0) {\n          let bufferLen = Buffer.byteLength(line, 'utf8')\n\n          if (bufferLen > self.api.config.servers.tcp.maxDataLength) {\n            let error = self.api.config.errors.dataLengthTooLarge(self.api.config.servers.tcp.maxDataLength, bufferLen)\n            self.log(error, 'error')\n            return self.sendMessage(connection, {status: 'error', error: error, context: 'response'})\n          }\n        }\n\n        if (line.length > 0) {\n          // increment at the start of the request so that responses can be caught in order\n          // on the client, this is not handled by the genericServer\n          connection.messageCount++\n          self._parseRequest(connection, line)\n        }\n      }\n\n      // on data event\n      connection.rawConnection.on('data', chunk => {\n        if (self._checkBreakChars(chunk)) {\n          connection.destroy()\n        } else {\n          connection.rawConnection.socketDataString += chunk.toString('utf-8').replace(/\\r/g, '\\n')\n          let index\n\n          // get delimiter\n          let delimiter = String(self.api.config.servers.tcp.delimiter)\n\n          while ((index = connection.rawConnection.socketDataString.indexOf(delimiter)) > -1) {\n            let data = connection.rawConnection.socketDataString.slice(0, index)\n            connection.rawConnection.socketDataString = connection.rawConnection.socketDataString.slice(index + delimiter.length)\n            data.split(delimiter).forEach(parseLine)\n          }\n        }\n      })\n\n      // on end event\n      connection.rawConnection.on('end', () => {\n        // if the connection isn't destroyed do it now\n        if (connection.destroyed !== true) {\n          try {\n            connection.rawConnection.end()\n          } catch (e) {}\n          connection.destroy()\n        }\n      })\n\n      // on error event\n      connection.rawConnection.on('error', e => {\n        if (connection.destroyed !== true) {\n          self.log(`server error: ${e}`, 'error')\n\n          try {\n            connection.rawConnection.end()\n          } catch (e) {}\n          connection.destroy()\n        }\n      });\n    });\n\n    // on actionComplete event\n    self.on('actionComplete', (data) => {\n      if (data.toRender === true) {\n        data.response.context = 'response'\n        self.sendMessage(data.connection, data.response, data.messageCount)\n      }\n    })\n  }\n\n  // --------------------------------------------------------------------------------------------------------- [Helpers]\n\n  /**\n   * Parse client request.\n   *\n   * @param connection  Client connection object.\n   * @param line        Request line to be parsed.\n   * @private\n   */\n  _parseRequest (connection, line) {\n    let self = this\n\n    let words = line.split(' ')\n\n    // get the verb how are\n    let verb = words.shift()\n\n    if (verb === 'file') {\n      if (words.length > 0) { connection.params.file = words[ 0 ] }\n      self.processFile(connection)\n      return\n    }\n\n    connection.verbs(verb, words, (error, data) => {\n      if (!error) {\n        // send an success response message\n        self.sendMessage(connection, {status: 'OK', context: 'response', data: data})\n      } else if (error.match('verb not found or not allowed')) {\n        // check for and attempt to check single-use params\n        try {\n          // parse JSON request\n          let requestHash = JSON.parse(line)\n\n          // pass all founded params to the connection object\n          if (requestHash.params !== undefined) {\n            connection.params = {}\n\n            for (let v in requestHash.params) { connection.params[ v ] = requestHash.params[ v ] }\n          }\n\n          // pass action name to the connection object, if exists\n          if (requestHash.action) { connection.params.action = requestHash.action }\n        } catch (e) { connection.params.action = verb }\n\n        // reset some connection properties\n        connection.error = null\n        connection.response = {}\n\n        // process actions\n        self.processAction(connection)\n      } else {\n        // send an error message\n        self.sendMessage(connection, {status: error, context: 'response', data: data})\n      }\n    })\n  }\n\n  /**\n   * Handle new connection.\n   *\n   * @param rawConnection Client raw connection object.\n   * @private\n   */\n  _handleConnection (rawConnection) {\n    let self = this;\n\n    // if the options are enabled, set keepAlive to true\n    if (self.api.config.servers.tcp.setKeepAlive === true) { rawConnection.setKeepAlive(true) }\n\n    // reset socket data\n    rawConnection.socketDataString = ''\n\n    // build a new connection object (will emit 'connection')\n    self.buildConnection({\n      rawConnection: rawConnection,\n      remoteAddress: rawConnection.remoteAddress,\n      remotePort: rawConnection.remotePort\n    })\n  }\n\n  /**\n   * Check if the chunk contains the break chars.\n   *\n   * @param chunk         Chunk to the analysed.\n   * @returns {boolean}   True if found, false otherwise.\n   * @private\n   */\n  _checkBreakChars (chunk) {\n    let found = false\n    let hexChunk = chunk.toString('hex', 0, chunk.length)\n\n    if (hexChunk === 'fff4fffd06') {\n      found = true // CTRL + C\n    } else if (hexChunk === '04') {\n      found = true // CTRL + D\n    }\n\n    return found\n  }\n\n  /**\n   * Try a graceful shutdown.\n   *\n   * We will wait a while to Stellar try response to the pending connections.\n   *\n   * @param next              Callback.\n   * @param alreadyShutdown   Informs if the server was already shutdown.\n   * @private\n   */\n  _gracefulShutdown (next, alreadyShutdown = false) {\n    let self = this\n\n    // if the server isn't already shutdown do it now\n    if (!alreadyShutdown || alreadyShutdown === false) { self.server.close() }\n\n    let pendingConnections = 0\n\n    // finish all pending connections\n    self.connections().forEach(connection => {\n      // if there is no pending actions destroy the connection\n      if (connection.pendingActions === 0) {\n        connection.destroy()\n        return\n      }\n\n      // increment the pending connections\n      pendingConnections++\n\n      if (!connection.rawConnection.shutDownTimer) {\n        connection.rawConnection.shutDownTimer = setTimeout(() => {\n          connection.destroy()\n        }, attributes.pendingShutdownWaitLimit)\n      }\n    })\n\n    if (pendingConnections > 0) {\n      self.log(`waiting on shutdown, there are still ${pendingConnections} connected clients waiting on a response`, 'notice')\n      setTimeout(() => { self._gracefulShutdown(next, true) }, 1000)\n    } else if (typeof next === 'function') {\n      next()\n    }\n  }\n\n}\n"],"sourceRoot":"/source/"}