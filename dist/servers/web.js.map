{"version":3,"sources":["servers/web.js"],"names":[],"mappings":"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","file":"servers/web.js","sourcesContent":["import fs from 'fs'\nimport qs from 'qs'\nimport url from 'url'\nimport path from 'path'\nimport zlib from 'zlib'\nimport etag from 'etag'\nimport Mime from 'mime'\nimport uuid from 'node-uuid'\nimport Utils from '../utils'\nimport formidable from 'formidable'\nimport GenericServer from '../genericServer'\nimport browser_fingerprint from 'browser_fingerprint'\n\n// server type\nlet type = 'web'\n\n// server attributes\nlet attributes = {\n  canChat: false,\n  logConnections: false,\n  logExits: false,\n  sendWelcomeMessage: false,\n  verbs: [\n    // no verbs for connections of this type, as they are to very short-lived\n  ]\n}\n\n/**\n * This implements the HTTP web server.\n */\nexport default class Web extends GenericServer {\n\n  /**\n   * Http server instance.\n   */\n  server = null\n\n  /**\n   * Constructor.\n   *\n   * @param api       api instance.\n   * @param options   map with the server options.\n   */\n  constructor (api, options) {\n    // call the super constructor\n    super(api, type, options, attributes)\n\n    let self = this\n\n    if ([ 'api', 'file' ].indexOf(self.api.config.servers.web.rootEndpointType) < 0) {\n      throw new Error(`api.config.servers.web.rootEndpointType can only be 'api' or 'file'.`)\n    }\n\n    //////////////////// [EVENTS]\n    self.on('connection', connection => {\n      self._determineRequestParams(connection, requestMode => {\n        switch (requestMode) {\n          case 'api':\n            self.processAction(connection)\n            break\n          case 'file':\n            self.processFile(connection)\n            break\n          case 'options':\n            self._respondToOptions(connection)\n            break\n          case 'client-lib':\n            self.processClientLib(connection)\n            break\n          case 'trace':\n            self._respondToTrace(connection)\n        }\n      })\n    })\n\n    // event to be executed after the action completion\n    self.on('actionComplete', data => { self._completeResponse(data) })\n\n  }\n\n  //////////////////// [REQUIRED METHODS]\n\n  /**\n   * Start the server instance.\n   *\n   * @param next  Callback function.\n   */\n  start (next) {\n    let self = this\n\n    // check if id to create a HTTP or a HTTPS server\n    if (self.options.secure === false) {\n      let http = require('http')\n      self.server = http.createServer((req, res) => { self._handleRequest(req, res) })\n    } else {\n      let https = require('https')\n      self.server = https.createServer(self.api.config.servers.web.serverOptions, (req, res) => {\n        self._handleRequest(req, res)\n      })\n    }\n\n    let bootAttempts = 0\n\n    self.server.on('error', e => {\n      bootAttempts++\n\n      if (bootAttempts < self.api.config.servers.web.bootAttempts) {\n        self.log(`cannot boot web server; trying again [${String(e)}]`, 'error')\n\n        if (bootAttempts === 1) { self._cleanSocket(self.options.bindIP, self.options.port) }\n\n        setTimeout(() => {\n          self.log('attempting to boot again...')\n          self.server.listen(self.options.port, self.options.bindIP)\n        }, 1000)\n      } else {\n        return next(new Error(`Cannot start web server @ ${self.options.bindIP}:${self.options.port} => ${e.message}`))\n      }\n    })\n\n    self.server.listen(self.options.port, self.options.bindIP, () => {\n      self.chmodSocket(self.options.bindIP, self.options.port)\n      next()\n    })\n  }\n\n  /**\n   * Stop server.\n   *\n   * @param next  Callback function.\n   */\n  stop (next) {\n    let self = this\n\n    // close the server socket\n    self.server.close()\n\n    // execute the callback function\n    process.nextTick(() => { next() })\n  }\n\n  /**\n   * Send a message to the client.\n   *\n   * @param connection  Connection object where the message must be sent.\n   * @param message     Message to be sent.\n   */\n  sendMessage (connection, message) {\n    let self = this\n\n    // response string\n    let stringResponse = ''\n\n    // if the connection is as 'HEAD' HTTP method we need to\n    // ensure the message is a string\n    if (connection.rawConnection.method !== 'HEAD') { stringResponse = String(message) }\n\n    // clean HTTP headers\n    self._cleanHeaders(connection)\n\n    // get the response headers\n    let headers = connection.rawConnection.responseHeaders\n\n    // get the response status code\n    let responseHttpCode = parseInt(connection.rawConnection.responseHttpCode)\n\n    // send the response to the client (use compression if active)\n    self.sendWithCompression(connection, responseHttpCode, headers, stringResponse)\n  }\n\n  /**\n   * Send a file to the client.\n   *\n   * @param connection      Connection object where the file must be sent.\n   * @param error           Error object, null if not exists.\n   * @param fileStream      FileStream for the requested file.\n   * @param mime            File mime type.\n   * @param length          File length in bytes.\n   * @param lastModified    Timestamp if the last modification.\n   */\n  sendFile (connection, error, fileStream, mime, length, lastModified) {\n    let self = this\n    let foundExpires = false\n    let foundCacheControl = false\n    let ifModifiedSince\n    let reqHeaders\n\n    // check if we should use cache mechanisms\n    connection.rawConnection.responseHeaders.forEach(pair => {\n      if (pair[ 0 ].toLowerCase() === 'expires') { foundExpires = true }\n      if (pair[ 1 ].toLowerCase() === 'cache-control') { foundCacheControl = true }\n    })\n\n    // get headers from the client request\n    reqHeaders = connection.rawConnection.req.headers\n\n    // get the 'if-modified-since' value if exists\n    if (reqHeaders[ 'if-modified-since' ]) { ifModifiedSince = new Date(reqHeaders[ 'if-modified-since' ]) }\n\n    // add mime type to the response headers\n    connection.rawConnection.responseHeaders.push([ 'Content-Type', mime ])\n\n    // check if file expires\n    if (foundExpires === false) {\n      connection.rawConnection.responseHeaders.push([ 'Expires',\n        new Date(new Date().getTime() + self.api.config.servers.web.flatFileCacheDuration * 1000).toUTCString() ])\n    }\n\n    // check if the client want use cache\n    if (foundCacheControl === false) {\n      connection.rawConnection.responseHeaders.push([ 'Cache-Control', 'max-age=' + self.api.config.servers.web.flatFileCacheDuration + ', must-revalidate, public' ])\n    }\n\n    // add a header to the response with the last modified timestamp\n    connection.rawConnection.responseHeaders.push([ 'Last-Modified', new Date(lastModified) ])\n\n    // clean the connection headers\n    self._cleanHeaders(connection)\n\n    // get the response headers\n    let headers = connection.rawConnection.responseHeaders\n\n    // if an error exists change the status code to 404\n    if (error) { connection.rawConnection.responseHttpCode = 404 }\n\n    // if the lastModified is smaller than ifModifiedSince we respond with a 304 (use cache)\n    if (ifModifiedSince && lastModified <= ifModifiedSince) { connection.rawConnection.responseHttpCode = 304 }\n\n    // check if is to use ETag\n    if (self.api.config.servers.web.enableEtag && fileStream) {\n      // get a file buffer\n      let fileBuffer = !Buffer.isBuffer(fileStream) ? new Buffer(fileStream.toString(), 'utf8') : fileStream\n\n      // build the ETag header\n      let fileEtag = etag(fileBuffer, {weak: true})\n\n      // push the header to the response\n      connection.rawConnection.responseHeaders.push([ 'ETag', fileEtag ])\n\n      let noneMatchHeader = reqHeaders[ 'if-none-match' ]\n      let cacheCtrlHeader = reqHeaders[ 'cache-control' ]\n      let noCache = false\n      let etagMatches\n\n      // check for no-cache cache request directive\n      if (cacheCtrlHeader && cacheCtrlHeader.indexOf('no-cache') !== -1) { noCache = true }\n\n      // parse if-none-match\n      if (noneMatchHeader) { noneMatchHeader = noneMatchHeader.split(/ *, */) }\n\n      // if-none-match\n      if (noneMatchHeader) {\n        etagMatches = noneMatchHeader.some(match => match === '*' || match === fileEtag || match === 'W/' + fileEtag)\n      }\n\n      // use the cached object\n      if (etagMatches && !noCache) { connection.rawConnection.responseHeaders = 304 }\n    }\n\n    // parse the HTTP status code to int\n    let responseHttpCode = parseInt(connection.rawConnection.responseHttpCode)\n\n    if (error) {\n      self.sendWithCompression(connection, responseHttpCode, headers, String(error))\n    } else if (responseHttpCode !== 304) {\n      self.sendWithCompression(connection, responseHttpCode, headers, null, fileStream, length)\n    } else {\n      connection.rawConnection.res.writeHead(responseHttpCode, headers)\n      connection.rawConnection.res.end()\n      connection.destroy()\n    }\n  }\n\n  /**\n   * Send a compressed message to the client.\n   *\n   * @param connection          Connection object where the message must be sent.\n   * @param responseHttpCode    HTTP Status code.\n   * @param headers             HTTP response headers.\n   * @param stringResponse      Response body.\n   * @param fileStream          FileStream, only needed if to send a file.\n   * @param fileLength          File size in bytes, only needed if is to send a file.\n   */\n  sendWithCompression (connection, responseHttpCode, headers, stringResponse, fileStream, fileLength) {\n    let self = this\n    let compressor, stringEncoder\n    let acceptEncoding = connection.rawConnection.req.headers[ 'accept-encoding' ]\n\n    // Note: this is not a conformant accept-encoding parser.\n    // https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options\n    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n    if (self.api.config.servers.web.compress === true) {\n      if (acceptEncoding.match(/\\bdeflate\\b/)) {\n        headers.push([ 'Content-Encoding', 'deflate' ])\n        compressor = zlib.createDeflate()\n        stringEncoder = zlib.deflate\n      } else if (acceptEncoding.match(/\\bgzip\\b/)) {\n        headers.push([ 'Content-Encoding', 'gzip' ])\n        compressor = zlib.createGzip()\n        stringEncoder = zlib.gzip\n      }\n    }\n\n    // the 'finish' event deontes a successful transfer\n    connection.rawConnection.res.on('finish', () => { connection.destroy() })\n\n    // the 'close' event deontes a failed transfer, but it is probably the client's fault\n    connection.rawConnection.res.on('close', () => { connection.destroy() })\n\n    if (fileStream) {\n      if (compressor) {\n        connection.rawConnection.res.writeHead(responseHttpCode, headers)\n        fileStream.pipe(compressor).pipe(connection.rawConnection.res)\n      } else {\n        headers.push([ 'Content-Length', fileLength ])\n        connection.rawConnection.res.writeHead(responseHttpCode, headers)\n        fileStream.pipe(connection.rawConnection.res)\n      }\n    } else {\n      if (stringEncoder) {\n        stringEncoder(stringResponse, function (error, zippedString) {\n          headers.push([ 'Content-Length', zippedString.length ])\n          connection.rawConnection.res.writeHead(responseHttpCode, headers)\n          connection.rawConnection.res.end(zippedString)\n        })\n      } else {\n        headers.push([ 'Content-Length', Buffer.byteLength(stringResponse) ])\n        connection.rawConnection.res.writeHead(responseHttpCode, headers)\n        connection.rawConnection.res.end(stringResponse)\n      }\n    }\n  }\n\n  /**\n   * Disconnect a client.\n   *\n   * @param connection\n   */\n  goodbye (connection) {\n    // disconnect handlers\n  }\n\n  // --------------------------------------------------------------------------------------------------------- [PRIVATE]\n\n  /**\n   * Handle the requests.\n   *\n   * @param req   Request object.\n   * @param res   Response object.\n   * @private\n   */\n  _handleRequest (req, res) {\n    let self = this\n\n    // get the client fingerprint\n    browser_fingerprint.fingerprint(req, self.api.config.servers.web.fingerprintOptions, (fingerprint, elementHash, cookieHash) => {\n      let responseHeaders = []\n      let cookies = Utils.parseCookies(req)\n      let responseHttpCode = 200\n      let method = req.method.toUpperCase()\n      let parsedURL = url.parse(req.url, true)\n      let i\n\n      // push all cookies from the request to the response\n      for (i in cookieHash) { responseHeaders.push([ i, cookieHash[ i ] ]) }\n\n      // set content type to JSON\n      responseHeaders.push([ 'Content-Type', 'application/json; charset=utf-8' ])\n\n      // push all the default headers to the response object\n      for (i in self.api.config.servers.web.httpHeaders) {\n        responseHeaders.push([ i, self.api.config.servers.web.httpHeaders[ i ] ])\n      }\n\n      // get the client IP\n      let remoteIP = req.connection.remoteAddress\n\n      // get the client port\n      let remotePort = req.connection.remotePort\n\n      // helpers for unix socket bindings with no forward\n      if (!remoteIP && !remotePort) {\n        remoteIP = '0.0.0.0'\n        remotePort = '0'\n      }\n\n      if (req.headers[ 'x-forwarded-for' ]) {\n        let parts\n        let forwardedIp = req.headers[ 'x-forwarded-for' ].split(',')[ 0 ]\n        if (forwardedIp.indexOf('.') >= 0 || (forwardedIp.indexOf('.') < 0 && forwardedIp.indexOf(':') < 0)) {\n          // IPv4\n          forwardedIp = forwardedIp.replace('::ffff:', '') // remove any IPv6 information, ie: '::ffff:127.0.0.1'\n          parts = forwardedIp.split(':')\n          if (parts[ 0 ]) { remoteIP = parts[ 0 ] }\n          if (parts[ 1 ]) { remotePort = parts[ 1 ] }\n        } else {\n          // IPv6\n          parts = Utils.parseIPv6URI(forwardedIp)\n          if (parts.host) { remoteIP = parts.host }\n          if (parts.port) { remotePort = parts.port }\n        }\n\n        if (req.headers[ 'x-forwarded-port' ]) { remotePort = req.headers[ 'x-forwarded-port' ] }\n      }\n\n      self.buildConnection({\n        // will emit 'connection'\n        rawConnection: {\n          req: req,\n          res: res,\n          params: {},\n          method: method,\n          cookies: cookies,\n          responseHeaders: responseHeaders,\n          responseHttpCode: responseHttpCode,\n          parsedURL: parsedURL\n        },\n        id: `${fingerprint}-${uuid.v4()}`,\n        fingerprint: fingerprint,\n        remoteAddress: remoteIP,\n        remotePort: remotePort\n      })\n    })\n  }\n\n  /**\n   * Change socket permission.\n   *\n   * @param bindIP\n   * @param port\n   */\n  chmodSocket (bindIP, port) {\n    let self = this\n\n    if (!bindIP && self.options.port.indexOf('/') >= 0) { fs.chmodSync(port, 0o777) }\n  }\n\n  /**\n   * Determine the request params.\n   *\n   * @param connection  Client connection object.\n   * @param callback    Callback function.\n   * @private\n   */\n  _determineRequestParams (connection, callback) {\n    let self = this\n\n    // determine if is a file or an api request\n    let requestMode = self.api.config.servers.web.rootEndpointType\n    let pathname = connection.rawConnection.parsedURL.pathname\n    let pathParts = pathname.split('/')\n    let matcherLength, i\n\n    // remove empty parts from the beginning of the path\n    while (pathParts[ 0 ] === '') { pathParts.shift() }\n\n    // if exist an empty part on the end of the path, remove it\n    if (pathParts[ pathParts.length - 1 ] === '') { pathParts.pop() }\n\n    if (pathParts[ 0 ] && pathParts[ 0 ] === self.api.config.servers.web.urlPathForActions) {\n      requestMode = 'api'\n      pathParts.shift()\n    } else if (pathParts[ 0 ] && pathParts[ 0 ] === self.api.config.servers.websocket.clientJsName) {\n      requestMode = 'client-lib'\n      pathParts.shift()\n    } else if (pathParts[ 0 ] && pathParts[ 0 ] === self.api.config.servers.web.urlPathForFiles) {\n      requestMode = 'file'\n      pathParts.shift()\n    } else if (pathParts[ 0 ] && pathname.indexOf(self.api.config.servers.web.urlPathForActions) === 0) {\n      requestMode = 'api'\n      matcherLength = self.api.config.servers.web.urlPathForActions.split('/').length\n      for (i = 0; i < (matcherLength - 1); i++) { pathParts.shift() }\n    }\n    else if (pathParts[ 0 ] && pathname.indexOf(self.api.config.servers.web.urlPathForFiles) === 0) {\n      requestMode = 'file'\n      matcherLength = self.api.config.servers.web.urlPathForFiles.split('/').length\n      for (i = 0; i < (matcherLength - 1); i++) { pathParts.shift() }\n    }\n\n    // split parsed URL by '.'\n    var extensionParts = connection.rawConnection.parsedURL.pathname.split('.')\n\n    if (extensionParts.length > 1) { connection.extension = extensionParts[ (extensionParts.length - 1) ] }\n\n    // OPTIONS\n    if (connection.rawConnection.method === 'OPTIONS') {\n      requestMode = 'options'\n      callback(requestMode)\n    }\n\n    // API\n    else if (requestMode === 'api') {\n      // enable trace mode\n      if (connection.rawConnection.method === 'TRACE') { requestMode = 'trace' }\n\n      let search = connection.rawConnection.parsedURL.search.slice(1)\n      self._fillParamsFromWebRequest(connection, qs.parse(search, self.api.config.servers.web.queryParseOptions))\n\n      connection.rawConnection.params.query = connection.rawConnection.parsedURL.query\n\n      if (connection.rawConnection.method !== 'GET' && connection.rawConnection.method !== 'HEAD' &&\n        ( connection.rawConnection.req.headers[ 'content-type' ] || connection.rawConnection.req.headers[ 'Content-Type' ] )) {\n        connection.rawConnection.form = new formidable.IncomingForm()\n\n        for (i in self.api.config.servers.web.formOptions) {\n          connection.rawConnection.form[ i ] = self.api.config.servers.web.formOptions[ i ]\n        }\n\n        connection.rawConnection.form.parse(connection.rawConnection.req, (error, fields, files) => {\n          if (error) {\n            self.log(`error processing form: ${String(error)}`, 'error')\n            connection.error = new Error('There was an error processing this form.')\n          } else {\n            connection.rawConnection.params.body = fields\n            connection.rawConnection.params.files = files\n            self._fillParamsFromWebRequest(connection, files)\n            self._fillParamsFromWebRequest(connection, fields)\n          }\n\n          if (self.api.config.servers.web.queryRouting !== true) { connection.params.action = null }\n\n          // process route\n          self.api.routes.processRoute(connection, pathParts)\n\n          callback(requestMode)\n        })\n      } else {\n        if (self.api.config.servers.web.queryRouting !== true) { connection.params.action = null }\n\n        // process route\n        self.api.routes.processRoute(connection, pathParts)\n\n        callback(requestMode)\n      }\n    } else if (requestMode === 'file') {\n      if (!connection.params.file) { connection.params.file = pathParts.join(path.sep) }\n\n      if (connection.params.file === '' || connection.params.file[ connection.params.file.length - 1 ] === '/') {\n        connection.params.file = connection.params.file + self.api.config.general.directoryFileType\n      }\n      callback(requestMode)\n    } else if (requestMode === 'client-lib') {\n      callback(requestMode)\n    }\n  }\n\n  processClientLib (connection) {\n    let self = this\n\n    // client lib\n    let file = path.normalize(\n      self.api.config.general.paths.temp + path.sep +\n      self.api.config.servers.websocket.clientJsName + '.js')\n\n    // define the file to be loaded\n    connection.params.file = file\n\n    // process like a file\n    self.processFile(connection)\n  }\n\n  /**\n   * Fill the connection with the web request params.\n   *\n   * @param connection  Connection object.\n   * @param varsHash    Request params.\n   * @private\n   */\n  _fillParamsFromWebRequest (connection, varsHash) {\n    // helper for JSON parts\n    let collapsedVarsHash = Utils.collapseObjectToArray(varsHash)\n\n    if (collapsedVarsHash !== false) {\n      // post was an array, lets call it \"payload\"\n      varsHash = {payload: collapsedVarsHash}\n    }\n\n    // copy requests params to connection object\n    for (let v in varsHash) { connection.params[ v ] = varsHash[ v ] }\n  }\n\n  /**\n   * Complete the response.\n   *\n   * THis add additional server info to the response message, and\n   * build the final response object.\n   *\n   * @param data  Data to be sent to the client.\n   * @private\n   */\n  _completeResponse (data) {\n    let self = this\n\n    if (data.toRender === true) {\n      if (self.api.config.servers.web.metadataOptions.serverInformation) {\n        let stopTime = new Date().getTime()\n\n        data.response.serverInformation = {\n          serverName: self.api.config.general.serverName,\n          apiVersion: self.api.config.general.apiVersion,\n          requestDuration: (stopTime - data.connection.connectedAt),\n          currentTime: stopTime\n        }\n      }\n    }\n\n    // check if is to use requester information\n    if (self.api.config.servers.web.metadataOptions.requesterInformation) {\n      data.response.requesterInformation = self._buildRequesterInformation(data.connection)\n    }\n\n    // is an error response?\n    if (data.response.error) {\n      if (self.api.config.servers.web.returnErrorCodes === true && data.connection.rawConnection.responseHttpCode === 200) {\n        if (data.actionStatus === 'unknown_action') {\n          data.connection.rawConnection.responseHttpCode = 404\n        } else if (data.actionStatus === 'missing_params') {\n          data.connection.rawConnection.responseHttpCode = 422\n        } else if (data.actionStatus === 'server_error') {\n          data.connection.rawConnection.responseHttpCode = 500\n        } else {\n          data.connection.rawConnection.responseHttpCode = 400\n        }\n      }\n    }\n\n    if (!data.response.error && data.action && data.params.apiVersion && self.api.actions.actions[ data.params.action ][ data.params.apiVersion ].matchExtensionMimeType === true && data.connection.extension) {\n      data.connection.rawConnection.responseHeaders.push([ 'Content-Type', Mime.lookup(data.connection.extension) ])\n    }\n\n    // if its an error response we need to serialize the error object\n    if (data.response.error) {\n      data.response.error = self.api.config.errors.serializers.servers.web(data.response.error)\n    }\n\n    let stringResponse = ''\n\n    // build the string response\n    if (self._extractHeader(data.connection, 'Content-Type').match(/json/)) {\n      stringResponse = JSON.stringify(data.response, null, self.api.config.servers.web.padding)\n      if (data.params.callback) {\n        data.connection.rawConnection.responseHeaders.push([ 'Content-Type', 'application/javascript' ])\n        stringResponse = data.connection.params.callback + '(' + stringResponse + ');'\n      }\n    } else {\n      stringResponse = data.response\n    }\n\n    // return the response to the client\n    self.sendMessage(data.connection, stringResponse)\n  }\n\n  /**\n   * Extract one header from a connection object.\n   *\n   * @param connection  Connection object from the header must be extracted.\n   * @param match       Header name.\n   * @returns {*}       Null if not found, otherwise the header value.\n   * @private\n   */\n  _extractHeader (connection, match) {\n    let i = connection.rawConnection.responseHeaders.length - 1\n\n    while (i >= 0) {\n      if (connection.rawConnection.responseHeaders[ i ][ 0 ].toLowerCase() === match.toLowerCase()) {\n        return connection.rawConnection.responseHeaders[ i ][ 1 ]\n      }\n      i--\n    }\n\n    return null\n  }\n\n  /**\n   * Build the requester information.\n   *\n   * @param connection\n   * @returns {{id: number, fingerprint: (*|browser_fingerprint.fingerprint|null), remoteIP: string, receivedParams: {}}}\n   * @private\n   */\n  _buildRequesterInformation (connection) {\n    // build the request information object\n    let requesterInformation = {\n      id: connection.id,\n      fingerprint: connection.fingerprint,\n      remoteIP: connection.remoteIP,\n      receivedParams: {}\n    }\n\n    // copy all the connection params to the request information\n    for (let param in connection.params) { requesterInformation.receivedParams[ param ] = connection.params[ param ] }\n\n    // return the request information\n    return requesterInformation\n  }\n\n  /**\n   * Remove some unnecessary headers from the response.\n   *\n   * @param connection  Client connection object.\n   * @private\n   */\n  _cleanHeaders (connection) {\n    // make a copy of the original headers\n    let originalHeaders = connection.rawConnection.responseHeaders.reverse()\n    let foundHeaders = []\n    let cleanedHeaders = []\n\n    // iterate all headers and remove duplications and unnecessary headers\n    for (let i in originalHeaders) {\n      // get header name and value\n      let key = originalHeaders[ i ][ 0 ]\n      let value = originalHeaders[ i ][ 1 ]\n\n      if (foundHeaders.indexOf(key.toLowerCase()) >= 0 && key.toLowerCase().indexOf('set-cookie') < 0) {\n        // ignore, it's a duplicate\n      } else if (connection.rawConnection.method === 'HEAD' && key === 'Transfer-Encoding') {\n        // ignore, we can't send this header for HEAD requests\n      } else {\n        foundHeaders.push(key.toLowerCase())\n        cleanedHeaders.push([ key, value ])\n      }\n    }\n\n    // set the clean headers on the connection\n    connection.rawConnection.responseHeaders = cleanedHeaders\n  }\n\n  /**\n   * Respond to an option request.\n   *\n   * @param connection  Connection object.\n   * @private\n   */\n  _respondToOptions (connection = null) {\n    let self = this\n\n    // inform the allowed methods\n    if (!self.api.config.servers.web.httpHeaders[ 'Access-Control-Allow-Methods' ] && !self._extractHeader(connection, 'Access-Control-Allow-Methods')) {\n      let methods = 'HEAD, GET, POST, PUT, DELETE, OPTIONS, TRACE'\n      connection.rawConnection.responseHeaders.push([ 'Access-Control-Allow-Methods', methods ])\n    }\n\n    // inform the allowed origins\n    if (!self.api.config.servers.web.httpHeaders[ 'Access-Control-Allow-Origin' ] && !self._extractHeader(connection, 'Access-Control-Allow-Origin')) {\n      var origin = '*'\n      connection.rawConnection.responseHeaders.push([ 'Access-Control-Allow-Origin', origin ])\n    }\n\n    // send the message to client\n    self.sendMessage(connection, '')\n  }\n\n  /**\n   * Respond to a trace request.\n   *\n   * @param connection  Client connection object.\n   * @private\n   */\n  _respondToTrace (connection) {\n    let self = this\n\n    // build the request information\n    let data = self._buildRequesterInformation(connection)\n\n    // build the response string and send it to the client\n    let stringResponse = JSON.stringify(data, null, self.api.config.servers.web.padding)\n    self.sendMessage(connection, stringResponse)\n  }\n\n  /**\n   * Try remove the stale unix socket.\n   *\n   * @param bindIP\n   * @param port\n   * @private\n   */\n  _cleanSocket (bindIP, port) {\n    let self = this\n\n    if (!bindIP && port.indexOf('/') >= 0) {\n      fs.unlink(port, error => {\n        if (error) {\n          self.log(`cannot remove stale socket @${port}:${error}`)\n        } else {\n          self.log(`removed stale unix socket @${port}`)\n        }\n      })\n    }\n  }\n}\n"],"sourceRoot":"/source/"}